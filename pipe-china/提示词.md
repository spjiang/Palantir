# 理论背景
    理论背景：palantir ontology它的本质理解：我们有一个关键的东西没有研究，就是我们看到的数据是一个结果，那么形成这个数据的过程是什么样的，促进数据和数据之间的流动和流动的行为规则因数是什么？这个我们没有研究，这个东西很多是我们个人经验，在头脑里面没有把它显性化成为相应的的规则定义。
    在看Palantir的本体论，就会发现它的核心不仅仅是数据，数据关系，更加重要的是行为建模、这个行为建模就是我们讲的算法规则，促进数据形成的行为、促进数据与数据之间的流转的行为。这个行为建模，包括行为的可视化、显现化，才是整个本体论最核心的内容。

# 场景展示

    根据以上理论背景，需要在 管网运维 场景下进行展示。

# 部署方式
    采用 docker 部署方式

# 程序技术栈
    前端采用 vue
    后端采用 python

# 流程架构

    L1 数据接入与治理
    L2 本体/语义选型
    L3 风险推理/模型
    L4 智能体决策
    L5 执行闭环/工作流
    L6 战报与追溯


# 数据生成
    生成数据及地图需要真实，经纬度地址为：北京市海淀区东北旺西路8号院中关村软件园一期尚东数字谷A区


# 需求内容 

## 页面1
    页面标题：L1 数据接入与治理

## 页面2
    页面标题：L2 本体/语义选型
    
    需求如下：
    1、数据导入,导入的是 需求文档.md 文件；
    2、需求给我写一个需求文档.md 里面包含需求内容，文档内容包含一个需求内容，根据内容提取本体，同时创建本体关系；
    3、用户手动导入需求文档.md 文件，导入成功后，自动创建本体，本自动搭建本体关系；
    4、自动搭建本体关系后，自动创建一个本体关系图；
    5、本体关系图，可以进行编辑，编辑后，自动保存本体关系图；
    6、需要找一个适合本体论行为建模的图数据库，并实现本体关系图的存储；
    7、同时可以手动创建实体、创建关系；
    8、页面显示关系图谱；
    9、支持关系图谱检索，根据本体检索出具有关系的图谱，递归下级图谱，同时可以配置显示几级图谱关系；
   
## 页面3
    页面标题：L3 风险推理/模型

    根据其它页面真实完成当前功能。

    页面展示数字孪生地图，风险数据在数字孪生上面进行展示；

## 页面4
    页面标题：L4 智能体决策
    需要真实的对接 DeepSeek。
    根据其它页面真实完成当前功能。

## 页面5
    页面标题：L5 执行闭环/工作流
    根据其它页面真实完成当前功能。

## 页面6
    页面标题：L6 战报与追溯
    根据其它页面真实完成当前功能。

# 限制
    只能在pipe-china 目录下，不要使用其它目录中任何文件，及影响其它目录。



# 需求 2

本体数据：已创建节点 25 个，关系 13 个，本体数据和对应的关系数据创建成功后，需要前端页面进行本体数据列表展示，并可以进行编辑本体和关系。效果如图，点击节点并进行编辑等相关操作，一定要把页面做成真正的产品，而不是演示 demo

# 需求3
需求文档导入后，识别到的本体数据和关系数据，先不用马上进行图数据库存储，需要把把本体数据和关系数据进行展示出来，用户在页面上进行可以进行编辑本体数据和关系数据。操作完毕后点击确认，才能进行图数据库存储。存储成功后，页面上马上更新图谱画布。

# 需求4 
根据当前需求文档识别到的本体数据和关系数据，是不是应该存储在临图数据库中，没上传一个需求文档就需要单独存储在一个临时的图数据库中，与整体的图数据库进行隔离，就像数据库一样创建一个临时表一样。
页面布局改成上下结构，
需要把单独独立用识别到的本体数据和关系数据显示生成一个图谱画布，让用户更加直观进行查看。点击画布中的节点，用户可以进行编辑。编辑确认没有问题，点击报错存储到对应正式的图数据库。
同时也应该提供一个图数据库查询，主要是针对当前当前需求文档识别到的本体数据和关系数据进行查询。

确认没有问题就存储在总的图数据库中。


整体的图数据库图谱也需要单独设计一个区域进行显示，并也提供图查询，编辑等相关操作




# 需求5

现在页面布局分上下两个区域
1、第一个区域提供，文件上传，提供当前用识别到的本体数据和关系数据显示生成一个图谱画布
2、第一个区域提供，点击画布节点进行本体数据修改和关系修改
3、第一个区域提供，当前用识别到的本体数据和关系数据显示生成一个图谱画布，进行图数据查询，查询结果同步更新当前临时的图谱画布显示。

4、第二个区域提供，整体的图谱画布
5、第二个区域提供，可以对整体的图谱画布进行编辑，从而更新本体数据和关系数据等
6、第二个区域提供，把以前存储的所有本体数据和关系数据生成一个整体的图谱画布（也就是真正正式数据），提供进行图数据查询，查询结果同步更新当前整体的图谱画布显示。


# 需求 6
请重新布局前端布局，不要在一个页面进行操作，按照后台管理风格进行设计，页面顶部修改为：L1 数据接入与治理 、 L2 本体/语义选型、L3 风险推理/模型、L4 智能体决策、L5 执行闭环/工作流、L6 战报与追溯 菜单。然后每个页面左边是具体的功能项菜单

# 需求 7
问题： 没有实现我想要的效果

前端监控 sse json 数据时，如 entities 对象下的数据，没介绍到一个完整的对象如：{"name": "管段", "label": "PipelineSegment", "props": {}},
就可以生成一行完整的一条数据展示在页面中，当然必须通过 html 形式暂时，每一行数据都必须带有编辑、删除功能，删除、编辑会更新当前完整的 json 对象。relations、behaviors、state_transitions，也是这样相同处理，如果用户编辑、删除等操作完毕，需要重新生成一个完整操作后的 json 数据，点击确认。此时操作后的完整 json 数据就可以通过点击“确认入库（草稿图谱）”

不要影响其它前端和逻辑，此需求作为新增独立的需求。

没有完成啊，生成的动态区域不需要隐藏这个区域啊，需要用户编辑确认。在确认之前不需要进入草稿谱图中，
如 entities 对象下的数据，没监控到接收到一个完整的对象如：{"name": "管段", "label": "PipelineSegment", "props": {}}后
就可以生成一行完整的一行 类似与表格中的一行，一条数据展示在页面中，当然必须通过 html 展示，每一行数据都必须带有编辑、删除功能，删除、编辑会更新当前完整的 json 对象。 


示例数据如下：


这个区域应该是：
标题：实体列表
{"name": "管段", "label": "PipelineSegment", "props": {}}, 对应表格一行 <tr>，每个属性用 td 类似这样的，并且带有编辑、删除功能等
生成的html 不要隐藏，需要二次上传才能把上次生成的 html tr td 清空。





提取的 json 数据如下：

{
  "entities": [
    {"name": "管段", "label": "PipelineSegment", "props": {}},
    {"name": "传感器", "label": "Sensor", "props": {"type": "压力/流量"}},
    {"name": "确认泄漏", "label": "State", "props": {}}
  ],
  "relations": [
    {"type": "has_sensor", "src": "管段", "dst": "传感器", "props": {}},
    {"type": "related_to", "src": "告警", "dst": "管段", "props": {}},
    {"type": "contains", "src": "事件", "dst": "证据", "props": {}}
  ],
  "behaviors": [
    {
      "name": "异常识别",
      "preconditions": ["传感器监测到压力异常或流量异常"],
      "affects": ["管段"],
      "state_from": "正常",
      "state_to": "疑似泄漏",
      "produces": ["异常识别记录"],
      "inputs": ["传感器数据", "告警"],
      "outputs": ["异常识别记录"],
      "effects": ["管段风险状态变为疑似泄漏"],
      "desc": "通过传感器数据识别管道异常，触发告警并改变管段风险状态。"
    },
    {
      "name": "执行与回写",
      "preconditions": ["运维任务已分配", "需要收集定位和照片证据"],
      "affects": ["运维任务", "管段"],
      "state_from": "疑似泄漏",
      "state_to": "确认泄漏",
      "produces": ["证据"],
      "inputs": ["运维任务"],
      "outputs": ["证据"],
      "effects": ["更新管段风险状态为确认泄漏或恢复正常"],
      "desc": "执行巡检任务，收集证据，并根据证据充分性更新管段风险状态。"
    }
  ],
  "rules": [
    {
      "name": "触发异常识别规则",
      "behavior": "异常识别",
      "trigger": "压力传感器读数超过阈值或流量传感器读数异常波动",
      "action": "创建异常识别记录，将管段状态改为疑似泄漏",
      "approval_required": false,
      "sla_minutes": 5,
      "required_evidence": ["传感器实时数据"],
      "forbids": [],
      "allows": ["处置决策"],
      "involves": ["管段", "传感器", "告警"]
    },
    {
      "name": "触发执行与回写规则（证据不足）",
      "behavior": "执行与回写",
      "trigger": "运维任务完成但未收集到充分证据",
      "action": "将管段风险状态更新为正常",
      "approval_required": false,
      "sla_minutes": 60,
      "required_evidence": [],
      "forbids": [],
      "allows": [],
      "involves": ["运维任务", "管段"]
    }
  ],
  "state_transitions": [
    {"object": "管段", "from": "正常", "to": "疑似泄漏", "via": "异常识别"},
    {"object": "管段", "from": "疑似泄漏", "to": "确认泄漏", "via": "执行与回写"},
    {"object": "管段", "from": "疑似泄漏", "to": "正常", "via": "执行与回写"}
  ]
}

根据提取的json数据，生成 html 表格。
表格1： 提取的 entities 命名为"对象列表如下"：
前端代码监控通过 sse 获取到大模型返货的 json字符串，监控到entities下的对象字符串，发现如完整获取到一个 json 对象{"name": "管段", "label": "PipelineSegment", "props": {}} 就可以动态生成 td 数据行了
第一行：第一列：name对应名称，第二列：label对应标签，第三列：props对应属性，第四列：操作，操作包含编辑弹窗，修改当前此行{"name": "管段", "label": "PipelineSegment", "props": {}} json 内容。
循环显示entities下面的对象：如每一行显示:{"name": "管段", "label": "PipelineSegment", "props": {}},

表格2: 提取的 relations 命令为:关系列表如下：
前端代码监控通过 sse 获取到大模型返货的 json字符串，监控到relations下的对象字符串，发现如完整获取到一个 json 对象{"type": "contains", "src": "事件", "dst": "证据", "props": {}}就可以动态生成 td 数据行了
第一行：第一列：type对应列表，第二列：src 源，第三列 dst目标，第四列：props对应属性，第四列：操作
循环显示relations下面的对象：如每一行显示:: {"type": "contains", "src": "事件", "dst": "证据", "props": {}}

behaviors、rules、state_transitions 也同样规则进行。


动态监控/ontology/extract/stream 这个接口实时的动态生成行为、规则、状态、对象、关系数据，当。前端代码监控通过 sse 获取到大模型返回的 json字符串，监控到entities下的对象字符串完整时，发现如完整获取到一个 json 对象{"name": "管段", "label": "PipelineSegment", "props": {}} 就显示到图谱画布右边对应的对象列表中。监控一条完整entities 下面的对象 json 字符串能完整的拼装成一个对象时，就实时动态生成一条数据，


/ontology/extract/stream接口返回的 json 结构就是如下结构
{
    "entities": [
      {"name": "管段", "label": "PipelineSegment", "props": {}},
      {"name": "传感器", "label": "Sensor", "props": {"type": "压力/流量"}},
      {"name": "告警", "label": "Alarm", "props": {"type": "压力异常/流量异常"}},
      {"name": "风险状态", "label": "RiskState", "props": {"value": "正常/疑似泄漏/确认泄漏"}},
      {"name": "运维任务", "label": "MaintenanceTask", "props": {"type": "巡检/处置"}},
      {"name": "证据", "label": "Evidence", "props": {"type": "定位/照片"}},
      {"name": "事件", "label": "Incident", "props": {}},
      {"name": "异常识别记录", "label": "Artifact", "props": {}},
      {"name": "正常", "label": "State", "props": {}},
      {"name": "疑似泄漏", "label": "State", "props": {}},
      {"name": "确认泄漏", "label": "State", "props": {}}
    ],
    "relations": [
      {"type": "has_sensor", "src": "管段", "dst": "传感器", "props": {}},
      {"type": "related_to", "src": "告警", "dst": "管段", "props": {}},
      {"type": "has_risk_state", "src": "管段", "dst": "风险状态", "props": {}},
      {"type": "targets", "src": "运维任务", "dst": "管段", "props": {}},
      {"type": "has_evidence", "src": "运维任务", "dst": "证据", "props": {}},
      {"type": "contains", "src": "事件", "dst": "告警", "props": {}},
      {"type": "contains", "src": "事件", "dst": "运维任务", "props": {}},
      {"type": "contains", "src": "事件", "dst": "证据", "props": {}}
    ],
    "behaviors": [
      {
        "name": "异常识别",
        "preconditions": ["传感器监测到压力异常或流量异常"],
        "affects": ["管段"],
        "state_from": "正常",
        "state_to": "疑似泄漏",
        "produces": ["异常识别记录"],
        "inputs": ["传感器数据", "告警"],
        "outputs": ["异常识别记录"],
        "effects": ["管段风险状态变为疑似泄漏"],
        "desc": "基于传感器异常数据识别管段潜在泄漏风险"
      },
      {
        "name": "处置决策",
        "preconditions": ["管段风险状态为疑似泄漏"],
        "affects": ["管段"],
        "state_from": "疑似泄漏",
        "state_to": "疑似泄漏",
        "produces": ["运维任务"],
        "inputs": ["异常识别记录"],
        "outputs": ["运维任务"],
        "effects": ["生成巡检任务"],
        "desc": "根据疑似泄漏状态决策并生成巡检任务"
      },
      {
        "name": "执行与回写",
        "preconditions": ["存在关联管段的巡检任务", "任务已收集定位和照片证据"],
        "affects": ["运维任务", "管段"],
        "state_from": "疑似泄漏",
        "state_to": "确认泄漏",
        "produces": [],
        "inputs": ["运维任务", "证据"],
        "outputs": [],
        "effects": ["管段风险状态根据证据充分性迁移"],
        "desc": "执行巡检任务并根据证据回写管段风险状态"
      }
    ],
    "rules": [
      {
        "name": "触发异常识别规则",
        "behavior": "异常识别",
        "trigger": "压力传感器读数超过阈值或流量传感器读数异常波动",
        "action": "创建异常识别记录并更新管段状态为疑似泄漏",
        "approval_required": false,
        "sla_minutes": 5,
        "required_evidence": ["压力异常告警", "流量异常告警"],
        "forbids": [],
        "allows": ["处置决策"],
        "involves": ["管段", "传感器", "告警"]
      },
      {
        "name": "触发处置决策规则",
        "behavior": "处置决策",
        "trigger": "管段风险状态变为疑似泄漏",
        "action": "创建巡检任务并指派",
        "approval_required": true,
        "sla_minutes": 30,
        "required_evidence": ["异常识别记录"],
        "forbids": [],
        "allows": ["执行与回写"],
        "involves": ["管段", "运维任务"]
      },
      {
        "name": "触发执行回写规则（证据充分）",
        "behavior": "执行与回写",
        "trigger": "巡检任务完成且证据（定位、照片）充分确认泄漏",
        "action": "更新管段风险状态为确认泄漏并关闭任务",
        "approval_required": false,
        "sla_minutes": 60,
        "required_evidence": ["定位证据", "照片证据"],
        "forbids": [],
        "allows": [],
        "involves": ["运维任务", "管段", "证据"]
      },
      {
        "name": "触发执行回写规则（证据不足）",
        "behavior": "执行与回写",
        "trigger": "巡检任务完成但证据不足",
        "action": "更新管段风险状态为正常并关闭任务",
        "approval_required": false,
        "sla_minutes": 60,
        "required_evidence": ["定位证据", "照片证据"],
        "forbids": [],
        "allows": [],
        "involves": ["运维任务", "管段", "证据"]
      }
    ],
    "state_transitions": [
      {"object": "管段", "from": "正常", "to": "疑似泄漏", "via": "异常识别"},
      {"object": "管段", "from": "疑似泄漏", "to": "确认泄漏", "via": "执行与回写"},
      {"object": "管段", "from": "疑似泄漏", "to": "正常", "via": "执行与回写"}
    ]
  }
前端调用 /ontology/extract/stream接口时，获取返回数据时，
每接收到数据字符串就需要判断，如 发现 {"entities": [  说明就开始返回实体下面对象了，如{"name": "传感器", "label": "Sensor", "props": {"type": "压力/流量"}},发现这个如{"name": "传感器", "label": "Sensor", "props": {"type": "压力/流量"}},完成了，就开始在实体列表开始生成这个对象数据。
关系，行为、规则、状态数据也按照这个逻辑进行动态显示数据。这样页面采用动态感，高级感

提取的 json 结构如下：
最外层结构是：
{
    "entities": [],
    "relations":[],
    "behaviors":[],
    "rules":[],
    "state_transitions":[]
}
解析规则如下：当收到数据时，没 100 个字符开始进行统计，

如当发现第一符号{时，代表开始接收大模型提取的 json 数据开始了
left_brace_num = 记录左变花括号数量。
right_brace_num = 记录右变花括号数量。

left_brace_num =  1 时，代表开始接收大模型提取的 json 数据开始了
当检测到entities 字符串出现后，就代表开始获取对象数据了。
但检测到 [ 下面


rev_entities_start 接收对象数据开始
这两个之间就开始在前端实时更新 对象数据
rev_entities_end 接收对象数据接收

rev_relations_start 接收关系数据开始
这两个之间就开始在前端实时更新 关系数据
rev_relations_end 接收关系数据结束

rev_behaviors_start 接收行为数据开始
这两个之间就开始在前端实时更新 行为数据
rev_behaviors_end 接收行为数据结束

rev_rules_start 接收规则数据开始
这两个之间就开始在前端实时更新 规则数据
rev_rules_end 接收规则数据结束

rev_state_transitions_start 接收状态数据开始
这两个之间就开始在前端实时更新 状态数据
rev_state_transitions_end 接收状态数据结束









